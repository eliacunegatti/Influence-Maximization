from math import degrees
from tkinter import Label
import matplotlib.pyplot as plt
import pandas as pd
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
from matplotlib import animation
import sys
sys.path.insert(0, '')
from src.load import read_graph
'''
This file takes as input a .csv file generated by the graph_influence.py 
script and produces a plot in three dimensions showing the relationship/correlation between the three objective functions.

'''
DEGREE = 3
def regression(z,x):
    z, x = zip(*sorted(zip(z, x)))
    z = np.array(z).reshape((-1, 1))
    x = np.array(x)
    from sklearn.linear_model import LinearRegression
    from sklearn.preprocessing import PolynomialFeatures
    model = LinearRegression()
    model.fit(z, x)
    r_sq = model.score(z, x)
    #print('coeffWCient of determination:', r_sq)
    #print('slope:', model.coef_)
    #Ã¹polyfit = model.predict(model.fit(z))
    #print(polyfit)
    #return model.coef_
    #return model.intercept_
    # poly = PolynomialFeatures(degree=2, include_bias=False)
    # poly_features = poly.fit_transform(z)
    # from sklearn.linear_model import LinearRegression
    # poly_reg_model = LinearRegression()
    # poly_reg_model.fit(poly_features, x)
    # r_sq = poly_reg_model.score(poly_features, x)
    # print('coeffWCient of determination:', r_sq)
    # print('slope:', poly_reg_model.coef_)
    train_x = np.array(z)
    train_y = np.array(x)
    

    #plt.scatter(train_x, train_y)
    #plt.show(); 
    
    # building polynomial model
    polyModel = PolynomialFeatures(degree = DEGREE)
    xpol = polyModel.fit_transform(train_x.reshape(-1, 1))
    preg = polyModel.fit(xpol,train_y)

    # Builiding linear model
    liniearModel = LinearRegression(fit_intercept = True)
    liniearModel.fit(xpol, train_y[:, np.newaxis])

    #print(liniearModel.get_feature_names())
    # Fitting with linear model
    train_x = train_x[:10]
    polyfit = liniearModel.predict(preg.fit_transform(train_x.reshape(-1, 1)))
    
    #print('slope:', liniearModel.coef_, len(liniearModel.coef_[0]))
    #plt.plot(train_x, polyfit, color = 'red')
    #plt.show();
    return train_x, polyfit

def get_values(filename):
    df = pd.read_csv(filename, sep=",")
    x=  df["n_nodes"].to_list()
    z = df["influence"].to_list()
    z, x = zip(*sorted(zip(z, x)))

    return z,x
if __name__ == '__main__':
    
    #graphs = ['deezerEU', 'pgp', 'fb_politician','fb-pages-public-figure', 'facebook_combined', 'fb_org']
    #models = ['IC', 'WC']
    graphs = [ 'pgp', 'fb_politician','facebook_combined']
    models = ['LT']
    for idx, name in enumerate(graphs):
        for model in models:
            print(name, model, '-----')
            print(name, model, '-----')
            filename = 'experiments/{0}_8-{1}/run-{2}.csv'.format(name, model, 1)
            a ,b = get_values(filename)
            t8 = np.array([[b[i],a[i]] for i in range(len(b))])

            filename = 'experiments/{0}_4-{1}/run-{2}.csv'.format(name, model, 1)
            a ,b = get_values(filename)
            t4 = np.array([[b[i],a[i]] for i in range(len(b))])


            filename = 'experiments/{0}_2-{1}/run-{2}.csv'.format(name, model, 1)
            a ,b = get_values(filename)
            t2 = np.array([[b[i],a[i]] for i in range(len(b))])
            # if model == 'IC':
            #     model = 'WC'
            #     if idx < len(graphs) -1:
            #         filename = 'experiments/{0}-{1}/run-{2}.csv'.format(graphs[idx+1], model, 1)
            #     else:
            #         filename = 'experiments/{0}-{1}/run-{2}.csv'.format(graphs[0], model, 1)
            # else :
            #     model = 'IC'
            #     if idx < len(graphs) -1:
            #         filename = 'experiments/{0}-{1}/run-{2}.csv'.format(graphs[idx+1], model, 1)
            #     else:
            #         filename = 'experiments/{0}-{1}/run-{2}.csv'.format(graphs[0], model, 1)
            filename = 'experiments/{0}-{1}/run-{2}.csv'.format(name, model, 1)

            a ,b = get_values(filename)
            t = np.array([[b[i],a[i]] for i in range(len(b))])


            from scipy.spatial.distance import directed_hausdorff
            import similaritymeasures
            df = similaritymeasures.frechet_dist(t, t8)

            # area = similaritymeasures.area_between_two_curves(t, t8)

            # # quantify the difference between the two curves using
            # # Curve Length based similarity measure
            # cl = similaritymeasures.curve_length_measure(t, t8)

            # # quantify the difference between the two curves using
            # # Dynamic Time Warping distance

            # print(df, area, cl, pcm, d)
            # print the results

            from fastdtw import fastdtw
            scale = [8,4,2]
            diff = [fastdtw(t[:,0],t8[:,0])[0],fastdtw(t[:,0],t4[:,0])[0],fastdtw(t[:,0],t2[:,0])[0]]
            #diff = [pcm8, pcm4, pcm2]
            df = pd.DataFrame()
            df["scale"] = scale
            df["diff"] = [float(x) for x in diff]
            df.to_csv('coef/{0}-{1}'.format(name, model),index=False)     

            from scipy.spatial.distance import euclidean

            x = t[:,1]
            y = t2[:,1]
            x = (x - np.min(x)) / (np.max(x) - np.min(x))
            y = (y - np.min(y)) / (np.max(y) - np.min(y))
            print(x)
            print(y)
            dtw_distance, warp_path = fastdtw(x, y, dist=euclidean)

            fig, ax = plt.subplots(figsize=(6, 6))

            # Remove the border and axes ticks
            #fig.patch.set_visible(False)
            #ax.axis('off')

            for [map_x, map_y] in warp_path:
                ax.plot([map_x, map_y], [x[map_x], y[map_y]], '--k', linewidth=4)

            ax.plot(x, '-ro', label='x', linewidth=4, markersize=1, markerfacecolor='lightcoral', markeredgecolor='lightcoral')
            ax.plot(y, '-bo', label='y', linewidth=4, markersize=1, markerfacecolor='skyblue', markeredgecolor='skyblue')
            ax.set_title("DTW Distance", fontsize=28, fontweight="bold")

            fig.savefig("AA.png")
            #exit(0)
            #plt.show()
#------------------------------------------------------------------------------------------------------------------------
           
           
            plt.scatter(t[:,1],t[:,0],color="red",label='Original')
            plt.scatter(t2[:,1],t2[:,0],color="orange",label='2')
            plt.scatter(t4[:,1],t4[:,0],color="blue",label='4')
            plt.scatter(t8[:,1],t8[:,0],color="green",label='8')

            #plt.title('Facebook PolitLTians WC p=0.01 model')
            plt.xlabel('% Influenced Nodes')
            plt.ylabel('% Nodes as seed set')
            plt.legend()
            plt.xlim(0,100)
            plt.ylim(0,2.5)
            plt.legend()
            plt.title(name + ' ' +model )
            plt.show()

           
        