from math import degrees
from tkinter import Label
import matplotlib.pyplot as plt
import pandas as pd
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
from matplotlib import animation
import sys
sys.path.insert(0, '')
from src.load import read_graph
'''
This file takes as input a .csv file generated by the graph_influence.py 
script and produces a plot in three dimensions showing the relationship/correlation between the three objective functions.

'''
DEGREE = 3
def regression(z,x):
    z, x = zip(*sorted(zip(z, x)))
    z = np.array(z).reshape((-1, 1))
    x = np.array(x)
    from sklearn.linear_model import LinearRegression
    from sklearn.preprocessing import PolynomialFeatures
    model = LinearRegression()
    model.fit(z, x)
    r_sq = model.score(z, x)
    #print('coeffWCient of determination:', r_sq)
    #print('slope:', model.coef_)
    #Ã¹polyfit = model.predict(model.fit(z))
    #print(polyfit)
    #return model.coef_
    #return model.intercept_
    # poly = PolynomialFeatures(degree=2, include_bias=False)
    # poly_features = poly.fit_transform(z)
    # from sklearn.linear_model import LinearRegression
    # poly_reg_model = LinearRegression()
    # poly_reg_model.fit(poly_features, x)
    # r_sq = poly_reg_model.score(poly_features, x)
    # print('coeffWCient of determination:', r_sq)
    # print('slope:', poly_reg_model.coef_)
    train_x = np.array(z)
    train_y = np.array(x)
    

    #plt.scatter(train_x, train_y)
    #plt.show(); 
    
    # building polynomial model
    polyModel = PolynomialFeatures(degree = DEGREE)
    xpol = polyModel.fit_transform(train_x.reshape(-1, 1))
    preg = polyModel.fit(xpol,train_y)

    # Builiding linear model
    liniearModel = LinearRegression(fit_intercept = True)
    liniearModel.fit(xpol, train_y[:, np.newaxis])

    #print(liniearModel.get_feature_names())
    # Fitting with linear model
    train_x = train_x[:10]
    polyfit = liniearModel.predict(preg.fit_transform(train_x.reshape(-1, 1)))
    
    #print('slope:', liniearModel.coef_, len(liniearModel.coef_[0]))
    #plt.plot(train_x, polyfit, color = 'red')
    #plt.show();
    return train_x, polyfit

def get_values(filename):
    df = pd.read_csv(filename, sep=",")
    x=  df["n_nodes"].to_list()
    z = df["influence"].to_list()
    z, x = zip(*sorted(zip(z, x)))

    return z,x
if __name__ == '__main__':
    
    graphs = ['deezerEU', 'pgp', 'fb_politician','fb-pages-public-figure', 'facebook_combined', 'fb_org']
    models = ['IC', 'WC']
    for idx, name in enumerate(graphs):
        for model in models:
            print(name, model, '-----')
            print(name, model, '-----')
            filename = 'experiments/{0}_8-{1}/run-{2}.csv'.format(name, model, 1)
            a ,b = get_values(filename)
            t8 = np.array([[b[i],a[i]] for i in range(len(b))])

            filename = 'experiments/{0}_4-{1}/run-{2}.csv'.format(name, model, 1)
            a ,b = get_values(filename)
            t4 = np.array([[b[i],a[i]] for i in range(len(b))])


            filename = 'experiments/{0}_2-{1}/run-{2}.csv'.format(name, model, 1)
            a ,b = get_values(filename)
            t2 = np.array([[b[i],a[i]] for i in range(len(b))])
            # if model == 'IC':
            #     model = 'WC'
            #     if idx < len(graphs) -1:
            #         filename = 'experiments/{0}-{1}/run-{2}.csv'.format(graphs[idx+1], model, 1)
            #     else:
            #         filename = 'experiments/{0}-{1}/run-{2}.csv'.format(graphs[0], model, 1)
            # else :
            #     model = 'IC'
            #     if idx < len(graphs) -1:
            #         filename = 'experiments/{0}-{1}/run-{2}.csv'.format(graphs[idx+1], model, 1)
            #     else:
            #         filename = 'experiments/{0}-{1}/run-{2}.csv'.format(graphs[0], model, 1)
            filename = 'experiments/{0}-{1}/run-{2}.csv'.format(name, model, 1)

            a ,b = get_values(filename)
            t = np.array([[b[i],a[i]] for i in range(len(b))])


            from scipy.spatial.distance import directed_hausdorff
            import similaritymeasures
            df = similaritymeasures.frechet_dist(t, t8)

            # area = similaritymeasures.area_between_two_curves(t, t8)

            # # quantify the difference between the two curves using
            # # Curve Length based similarity measure
            # cl = similaritymeasures.curve_length_measure(t, t8)

            # # quantify the difference between the two curves using
            # # Dynamic Time Warping distance

            # print(df, area, cl, pcm, d)
            # print the results


            scale = [8,4,2]
            diff = [similaritymeasures.frechet_dist(t[:,1],t8[:,1]),similaritymeasures.frechet_dist(t[:,1],t4[:,1]),similaritymeasures.frechet_dist(t[:,1],t2[:,1])]
            #diff = [pcm8, pcm4, pcm2]
            df = pd.DataFrame()
            df["scale"] = scale
            df["diff"] = [float(x) for x in diff]
            df.to_csv('coef/{0}-{1}'.format(name, model),index=False)     

            import numpy as np
            import matplotlib.pyplot as plt
            from scipy.spatial.distance import euclidean
            from fastdtw import fastdtw as fdw
            
            start=0
            end=2*np.pi
            step=0.1
            k=2
            
            #x1=np.arange(start,end,k*step)
            #x2=np.arange(start,end/k,step)

            sin1=plt.plot(t[:,1],t[:,0])
            
            plt.setp(sin1,color='b',linewidth=2.0)
            
            sin2=plt.plot(t8[:,1],t8[:,0])
            plt.setp(sin2,color='r',linewidth=2.0)
            time_series_A=  np.array([[t[:,1][i],t[:,0][i]] for i in range(len(t))])

            time_series_B= np.array([[t8[:,1][i],t8[:,0][i]] for i in range(len(t8))])

            distance, path = fdw(time_series_A, time_series_B, dist=euclidean)
            print(distance)
            #print(path)


            
            
            index_a,index_b=zip(*path)
            for i in index_a:
                try:
                    x1=time_series_A[i][0]
                    y1=time_series_A[i][1]
                    x2=time_series_B[i][0]
                    y2=time_series_B[i][1]
                
                    plt.plot([x1, x2], [y1, y2], color='k', linestyle='-', linewidth=2)
                except:
                    pass
            plt.show()
#------------------------------------------------------------------------------------------------------------------------
           
           
            # plt.scatter(z2,x2,color="red",label='Original')
            # plt.scatter(z1,x1,color="orange",label='2')
            # plt.scatter(z0,x0,color="blue",label='4')
            # plt.scatter(z,x,color="green",label='8')

            # #plt.title('Facebook PolitLTians WC p=0.01 model')
            # plt.xlabel('% Influenced Nodes')
            # plt.ylabel('% Nodes as seed set')
            # plt.legend()
            # plt.xlim(0,100)
            # plt.ylim(0,2.5)
            # plt.legend()
            # plt.title(name + ' ' +model )
            # plt.show()



            # scale = [8,4,2]
            # diff = [euclidean_distances(np.array(m.reshape(1, -1)) , np.array(m8.reshape(1, -1))),euclidean_distances(np.array(m.reshape(1, -1)) , np.array(m4.reshape(1, -1))),euclidean_distances(np.array(m.reshape(1, -1)) , np.array(m2.reshape(1, -1)))]
            # df = pd.DataFrame()
            # df["scale"] = scale
            # df["diff"] = [float(x) for x in diff]
            # df.to_csv('coef/{0}-{1}'.format(name, model),index=False)
           
            # plt.scatter(z2,x2,color="red",label='Original')
            # plt.scatter(z1,x1,color="orange",label='2')
            # plt.scatter(z0,x0,color="blue",label='4')
            # plt.scatter(z,x,color="green",label='8')

            # #plt.title('Facebook PolitLTians WC p=0.01 model')
            # plt.xlabel('% Influenced Nodes')
            # plt.ylabel('% Nodes as seed set')
            # plt.legend()
            # plt.xlim(0,100)
            # plt.ylim(0,2.5)
            # plt.legend()
            # plt.title(name + ' ' +model )
            # plt.show()
